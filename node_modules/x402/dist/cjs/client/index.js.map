{"version":3,"sources":["../../../src/client/index.ts","../../../src/types/shared/evm/config.ts","../../../src/types/shared/evm/eip3009.ts","../../../src/types/shared/evm/wallet.ts","../../../src/schemes/exact/evm/sign.ts","../../../src/shared/base64.ts","../../../src/types/shared/money.ts","../../../src/types/shared/network.ts","../../../src/shared/svm/wallet.ts","../../../src/shared/svm/rpc.ts","../../../src/types/shared/wallet.ts","../../../src/types/shared/svm/regex.ts","../../../src/shared/network.ts","../../../src/types/verify/x402Specs.ts","../../../src/types/verify/facilitator.ts","../../../src/shared/evm/usdc.ts","../../../src/shared/svm/transaction.ts","../../../src/schemes/exact/evm/utils/paymentUtils.ts","../../../src/schemes/exact/evm/client.ts","../../../src/schemes/exact/svm/client.ts","../../../src/client/createPaymentHeader.ts","../../../src/client/preparePaymentHeader.ts","../../../src/client/selectPaymentRequirements.ts","../../../src/client/signPaymentHeader.ts"],"sourcesContent":["export * from \"./createPaymentHeader\";\nexport * from \"./preparePaymentHeader\";\nexport * from \"./selectPaymentRequirements\";\nexport * from \"./signPaymentHeader\";","import { Address } from \"viem\";\nimport { Address as SolanaAddress } from \"@solana/kit\";\n\nexport const config: Record<string, ChainConfig> = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\",\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USD Coin\",\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\",\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USD Coin\",\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\",\n  },\n  // solana devnet\n  \"103\": {\n    usdcAddress: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  // solana mainnet\n  \"101\": {\n    usdcAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  \"1328\": {\n    usdcAddress: \"0x4fcf1784b31630811181f670aea7a7bef803eaed\",\n    usdcName: \"USDC\",\n  },\n  \"1329\": {\n    usdcAddress: \"0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392\",\n    usdcName: \"USDC\",\n  },\n  \"137\": {\n    usdcAddress: \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\",\n    usdcName: \"USD Coin\",\n  },\n  \"80002\": {\n    usdcAddress: \"0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582\",\n    usdcName: \"USDC\",\n  },\n  \"3338\": {\n    usdcAddress: \"0xbbA60da06c2c5424f03f7434542280FCAd453d10\",\n    usdcName: \"USDC\",\n  },\n};\n\nexport type ChainConfig = {\n  usdcAddress: Address | SolanaAddress;\n  usdcName: string;\n};\n","export const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n};\n\nexport const authorizationPrimaryType = \"TransferWithAuthorization\";\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n} from \"viem/chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n  return createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nfunction getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n","import { Chain, getAddress, Hex, LocalAccount, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | LocalAccount,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset),\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\n// evm\nexport const SupportedEVMNetworks: Network[] = [\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n  [\"polygon\", 137],\n  [\"polygon-amoy\", 80002],\n  [\"peaq\", 3338],\n]);\n\n// svm\nexport const SupportedSVMNetworks: Network[] = [\"solana-devnet\", \"solana\"];\nexport const SvmNetworkToChainId = new Map<Network, number>([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101],\n]);\n\nexport const ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map(network => [\n    EvmNetworkToChainId.get(network),\n    network,\n  ]),\n) as Record<number, Network>;\n","import {\n  createKeyPairSignerFromBytes,\n  type KeyPairSigner,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  isKeyPairSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = KeyPairSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<KeyPairSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a solana KeyPairSigner wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is a solana KeyPairSigner wallet, false otherwise.\n */\nexport function isSignerWallet(wallet: SvmSigner): wallet is SvmSigner {\n  return isKeyPairSigner(wallet);\n}\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Default public RPC endpoint for Solana devnet\n */\nconst DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\n\n/**\n * Default public RPC endpoint for Solana mainnet\n */\nconst MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana devnet\n */\nconst DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana mainnet\n */\nconst MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n *\n * Converts an HTTP URL to a WebSocket URL\n *\n * @param url - The URL to convert to a WebSocket URL\n * @returns The WebSocket URL\n */\nfunction httpToWs(url: string): string {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n","import * as evm from \"./evm/wallet\";\nimport * as svm from \"../../shared/svm/wallet\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"./network\";\nimport { Hex } from \"viem\";\n\nexport type ConnectedClient = evm.ConnectedClient | svm.SvmConnectedClient;\nexport type Signer = evm.EvmSigner | svm.SvmSigner;\nexport type MultiNetworkSigner = { evm: evm.EvmSigner; svm: svm.SvmSigner };\n\n/**\n * Creates a public client configured for the specified network.\n *\n * @param network - The network to connect to.\n * @returns A public client instance connected to the specified chain.\n */\nexport function createConnectedClient(network: string): ConnectedClient {\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return evm.createConnectedClient(network);\n  }\n\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSvmConnectedClient(network);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key.\n *\n * @param network - The network to connect to.\n * @param privateKey - The private key to use for signing transactions.\n * @returns A wallet client instance connected to the specified chain with the provided private key.\n */\nexport function createSigner(network: string, privateKey: Hex | string): Promise<Signer> {\n  // evm\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return Promise.resolve(evm.createSigner(network, privateKey as Hex));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSignerFromBase58(privateKey as string);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Checks if the given wallet is an EVM signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is an EVM signer wallet, false otherwise.\n */\nexport function isEvmSignerWallet(wallet: Signer): wallet is evm.EvmSigner {\n  return evm.isSignerWallet(wallet as evm.EvmSigner) || evm.isAccount(wallet as evm.EvmSigner);\n}\n\n/**\n * Checks if the given wallet is an SVM signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is an SVM signer wallet, false otherwise\n */\nexport function isSvmSignerWallet(wallet: Signer): wallet is svm.SvmSigner {\n  return svm.isSignerWallet(wallet as svm.SvmSigner);\n}\n\n/**\n * Checks if the given wallet is a multi network signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is a multi network signer wallet, false otherwise\n */\nexport function isMultiNetworkSigner(wallet: object): wallet is MultiNetworkSigner {\n  return \"evm\" in wallet && \"svm\" in wallet;\n}\n","export const SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n","import { EvmNetworkToChainId, Network, SvmNetworkToChainId } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network)!;\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","import { Account, Address, Chain, Client, Transport } from \"viem\";\nimport { ChainConfig, config } from \"../../types/shared/evm/config\";\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC contract address for the current chain from the client\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns The USDC contract address for the current chain\n */\nexport function getUsdcAddress<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<transport, chain, account>): Address {\n  return config[client.chain!.id.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC contract address for a specific chain ID\n *\n * @deprecated Use `getUsdcChainConfigForChain` instead\n * @param chainId - The chain ID to get the USDC contract address for\n * @returns The USDC contract address for the specified chain\n */\nexport function getUsdcAddressForChain(chainId: number): Address {\n  return config[chainId.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC address and eip712 domain name for a specific chain ID\n *\n * @param chainId - The chain ID\n * @returns The USDC contract address and eip712 domain name  for the specified chain\n */\nexport function getUsdcChainConfigForChain(chainId: number): ChainConfig | undefined {\n  return config[chainId.toString()];\n}\n\n// Cache for storing the version value\nlet versionCache: string | null = null;\n\n/**\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns A promise that resolves to the USDC contract version string\n */\nexport async function getVersion<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\n  // Return cached version if available\n  if (versionCache !== null) {\n    return versionCache;\n  }\n\n  // Fetch and cache version if not available\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi,\n    functionName: \"version\",\n  });\n  versionCache = version as string;\n  return versionCache;\n}\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getUSDCBalance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\n  const chainId = client.chain!.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress as `0x${string}`,\n    abi,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  KeyPairSigner,\n  partiallySignTransaction,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n} from \"@solana/kit\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: KeyPairSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  // sign the transaction as the fee payer\n  const signedTransaction = await partiallySignTransaction([signer.keyPair], transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: false,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n","import { safeBase64Encode, safeBase64Decode } from \"../../../../shared\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"../../../../types\";\nimport {\n  PaymentPayload,\n  PaymentPayloadSchema,\n  ExactEvmPayload,\n  ExactSvmPayload,\n} from \"../../../../types/verify\";\n\n/**\n * Encodes a payment payload into a base64 string, ensuring bigint values are properly stringified\n *\n * @param payment - The payment payload to encode\n * @returns A base64 encoded string representation of the payment payload\n */\nexport function encodePayment(payment: PaymentPayload): string {\n  let safe: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(payment.network)) {\n    const evmPayload = payment.payload as ExactEvmPayload;\n    safe = {\n      ...payment,\n      payload: {\n        ...evmPayload,\n        authorization: Object.fromEntries(\n          Object.entries(evmPayload.authorization).map(([key, value]) => [\n            key,\n            typeof value === \"bigint\" ? (value as bigint).toString() : value,\n          ]),\n        ) as ExactEvmPayload[\"authorization\"],\n      },\n    };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.includes(payment.network)) {\n    safe = { ...payment, payload: payment.payload as ExactSvmPayload };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  throw new Error(\"Invalid network\");\n}\n\n/**\n * Decodes a base64 encoded payment string back into a PaymentPayload object\n *\n * @param payment - The base64 encoded payment string to decode\n * @returns The decoded and validated PaymentPayload object\n */\nexport function decodePayment(payment: string): PaymentPayload {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n\n  let obj: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactEvmPayload,\n    };\n  }\n\n  // svm\n  else if (SupportedSVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactSvmPayload,\n    };\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n","import { Address, Chain, LocalAccount, Transport } from \"viem\";\nimport { isSignerWallet, SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 600, // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = isSignerWallet(client) ? client.account!.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n","import { encodePayment } from \"../../utils\";\nimport {\n  Address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction,\n  type KeyPairSigner,\n  fetchEncodedAccount,\n  TransactionSigner,\n  Instruction,\n} from \"@solana/kit\";\nimport { PaymentPayload, PaymentRequirements } from \"../../../types/verify\";\nimport { X402Config } from \"../../../types/config\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenInstruction,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { getRpcClient } from \"../../../shared/svm/rpc\";\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a base64 encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  const paymentPayload = await createAndSignPayment(\n    client,\n    x402Version,\n    paymentRequirements,\n    config,\n  );\n  return encodePayment(paymentPayload);\n}\n\n/**\n * Creates and signs a payment for the given client and payment requirements.\n *\n * @param client - The signer instance used to create and sign the payment tx\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a payment payload containing a base64 encoded solana token transfer tx\n */\nexport async function createAndSignPayment(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<PaymentPayload> {\n  const transactionMessage = await createTransferTransactionMessage(\n    client,\n    paymentRequirements,\n    config,\n  );\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // return payment payload\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version: x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction,\n    },\n  } as PaymentPayload;\n}\n\n/**\n * Creates a transfer transaction message for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the transfer transaction message\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the transaction message with the transfer instruction\n */\nasync function createTransferTransactionMessage(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n) {\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n\n  // create the transfer instruction\n  const transferInstructions = await createAtaAndTransferInstructions(\n    client,\n    paymentRequirements,\n    config,\n  );\n\n  // create tx to simulate\n  const feePayer = paymentRequirements.extra?.feePayer as Address;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageComputeUnitPrice(1, tx), // 1 microlamport priority fee\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => appendTransactionMessageInstructions(transferInstructions, tx),\n  );\n\n  // estimate the compute budget limit (gas limit)\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n\n  // finalize the transaction message by adding the compute budget limit and blockhash\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    tx =>\n      prependTransactionMessageInstruction(\n        getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n        tx,\n      ),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n\n  return tx;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will determine which transfer instruction to create\n * based on the program that created the token (token-2022 or token).\n *\n * @param client - The signer instance used to create the transfer instruction\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the create ATA (if needed) and transfer instruction\n */\nasync function createAtaAndTransferInstructions(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<Instruction[]> {\n  const { asset } = paymentRequirements;\n\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const tokenMint = await fetchMint(rpc, asset as Address);\n  const tokenProgramAddress = tokenMint.programAddress;\n\n  // validate that the asset was created by a known token program\n  if (\n    tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n    tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n  ) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n\n  const instructions: Instruction[] = [];\n\n  // create the ATA (if needed)\n  const createAtaIx = await createAtaInstructionOrUndefined(\n    paymentRequirements,\n    tokenProgramAddress,\n    config,\n  );\n  if (createAtaIx) {\n    instructions.push(createAtaIx);\n  }\n\n  // create the transfer instruction\n  const transferIx = await createTransferInstruction(\n    client,\n    paymentRequirements,\n    tokenMint.data.decimals,\n    tokenProgramAddress,\n  );\n  instructions.push(transferIx);\n\n  return instructions;\n}\n\n/**\n * Returns a create ATA instruction for the payTo address if the ATA account does not exist.\n * The create ATA instruction will be paid for by the feePayer in the payment requirements.\n *\n * This function will work for both spl-token and token-2022.\n *\n * Returns undefined if the ATA account already exists.\n *\n * @param paymentRequirements - The payment requirements\n * @param tokenProgramAddress - The address of the token program\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the create ATA instruction or undefined if the ATA account already exists\n * @throws an error if the feePayer is not provided in the payment requirements\n */\nasync function createAtaInstructionOrUndefined(\n  paymentRequirements: PaymentRequirements,\n  tokenProgramAddress: Address,\n  config?: X402Config,\n): Promise<Instruction | undefined> {\n  const { asset, payTo, extra } = paymentRequirements;\n  const feePayer = extra?.feePayer as Address;\n\n  // feePayer is required\n  if (!feePayer) {\n    throw new Error(\n      \"feePayer is required in paymentRequirements.extra in order to set the \" +\n        \"facilitator as the fee payer for the create associated token account instruction\",\n    );\n  }\n\n  // derive the ATA of the payTo address\n  const [destinationATAAddress] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  // check if the ATA exists\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const maybeAccount = await fetchEncodedAccount(rpc, destinationATAAddress);\n\n  // if the ATA does not exist, return an instruction to create it\n  if (!maybeAccount.exists) {\n    return getCreateAssociatedTokenInstruction({\n      payer: paymentRequirements.extra?.feePayer as TransactionSigner<string>,\n      ata: destinationATAAddress,\n      owner: payTo as Address,\n      mint: asset as Address,\n      tokenProgram: tokenProgramAddress,\n    });\n  }\n\n  // if the ATA exists, return undefined\n  return undefined;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will create a transfer instruction for a token created by either\n * the token program or the token-2022 program.\n *\n * @param client - The signer instance who's tokens will be debited from\n * @param paymentRequirements - The payment requirements\n * @param decimals - The decimals of the token\n * @param tokenProgramAddress - The address of the token program\n * @returns A promise that resolves to the transfer instruction\n */\nasync function createTransferInstruction(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n  decimals: number,\n  tokenProgramAddress: Address,\n): Promise<Instruction> {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  return getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset as Address,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: decimals,\n    },\n    { programAddress: tokenProgramAddress },\n  );\n}\n","import { createPaymentHeader as createPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { createPaymentHeader as createPaymentHeaderExactSVM } from \"../schemes/exact/svm/client\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, isSvmSignerWallet, MultiNetworkSigner, Signer, SupportedEVMNetworks, SupportedSVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements } from \"../types/verify\";\nimport { X402Config } from \"../types/config\";\n\n/**\n * Creates a payment header based on the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the created payment header string\n */\nexport async function createPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  // exact scheme\n  if (paymentRequirements.scheme === \"exact\") {\n    // evm\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n      if (!isEvmSignerWallet(evmClient)) {\n        throw new Error(\"Invalid evm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactEVM(\n        evmClient,\n        x402Version,\n        paymentRequirements,\n      );\n    }\n    // svm\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      const svmClient = isMultiNetworkSigner(client) ? client.svm : client;\n      if (!isSvmSignerWallet(svmClient)) {\n        throw new Error(\"Invalid svm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactSVM(\n        svmClient,\n        x402Version,\n        paymentRequirements,\n        config,\n      );\n    }\n    throw new Error(\"Unsupported network\");\n  }\n  throw new Error(\"Unsupported scheme\");\n}","import { Address } from \"viem\";\nimport { preparePaymentHeader as preparePaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Prepares a payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload that can be used to create a payment header\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return preparePaymentHeaderExactEVM(from, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}\n","import { Network, PaymentRequirements } from \"../types\";\nimport { getUsdcChainConfigForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\"): PaymentRequirements {\n  // Sort `base` payment requirements to the front of the list. This is to ensure that base is preferred if available.\n  paymentRequirements.sort((a, b) => {\n    if (a.network === \"base\" && b.network !== \"base\") {\n      return -1;\n    }\n    if (a.network !== \"base\" && b.network === \"base\") {\n      return 1;\n    }\n    return 0;\n  });\n\n  // Filter down to the scheme/network if provided\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\n    // If the scheme is not provided, we accept any scheme.\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    // If the chain is not provided, we accept any chain.\n    const isExpectedChain = !network || (Array.isArray(network) ? network.includes(requirement.network) : network == requirement.network);\n\n    return isExpectedScheme && isExpectedChain;\n  });\n\n  // Filter down to USDC requirements\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\n    // If the address is a USDC address, we return it.\n    return requirement.asset === getUsdcChainConfigForChain(getNetworkId(requirement.network))?.usdcAddress;\n  });\n\n  // Prioritize USDC requirements if available\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  // If no USDC requirements are found, return the first broadly accepted requirement.\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  // If no matching requirements are found, return the first requirement.\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\") => PaymentRequirements;\n\n","import { signPaymentHeader as signPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { encodePayment } from \"../schemes/exact/evm/utils/paymentUtils\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, MultiNetworkSigner, Signer, SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the encoded signed payment header string\n */\nexport async function signPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n    if (!isEvmSignerWallet(evmClient)) {\n      throw new Error(\"Invalid evm wallet client provided\");\n    }\n    const signedPaymentHeader = await signPaymentHeaderExactEVM(evmClient, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}"],"mappings":"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","names":["createPaymentHeader","preparePaymentHeader","signPaymentHeader","import_viem","import_zod","import_kit","isSignerWallet","isSignerWallet","import_zod","import_zod","import_kit","import_kit","createPaymentHeader","config","tx","createPaymentHeader","config","preparePaymentHeader","signPaymentHeader"]}