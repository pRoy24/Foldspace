{"version":3,"sources":["../../src/client/createPaymentHeader.ts","../../src/client/preparePaymentHeader.ts","../../src/client/selectPaymentRequirements.ts","../../src/client/signPaymentHeader.ts"],"sourcesContent":["import { createPaymentHeader as createPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { createPaymentHeader as createPaymentHeaderExactSVM } from \"../schemes/exact/svm/client\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, isSvmSignerWallet, MultiNetworkSigner, Signer, SupportedEVMNetworks, SupportedSVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements } from \"../types/verify\";\nimport { X402Config } from \"../types/config\";\n\n/**\n * Creates a payment header based on the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the created payment header string\n */\nexport async function createPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  // exact scheme\n  if (paymentRequirements.scheme === \"exact\") {\n    // evm\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n      if (!isEvmSignerWallet(evmClient)) {\n        throw new Error(\"Invalid evm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactEVM(\n        evmClient,\n        x402Version,\n        paymentRequirements,\n      );\n    }\n    // svm\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      const svmClient = isMultiNetworkSigner(client) ? client.svm : client;\n      if (!isSvmSignerWallet(svmClient)) {\n        throw new Error(\"Invalid svm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactSVM(\n        svmClient,\n        x402Version,\n        paymentRequirements,\n        config,\n      );\n    }\n    throw new Error(\"Unsupported network\");\n  }\n  throw new Error(\"Unsupported scheme\");\n}","import { Address } from \"viem\";\nimport { preparePaymentHeader as preparePaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Prepares a payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload that can be used to create a payment header\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return preparePaymentHeaderExactEVM(from, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}\n","import { Network, PaymentRequirements } from \"../types\";\nimport { getUsdcChainConfigForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\"): PaymentRequirements {\n  // Sort `base` payment requirements to the front of the list. This is to ensure that base is preferred if available.\n  paymentRequirements.sort((a, b) => {\n    if (a.network === \"base\" && b.network !== \"base\") {\n      return -1;\n    }\n    if (a.network !== \"base\" && b.network === \"base\") {\n      return 1;\n    }\n    return 0;\n  });\n\n  // Filter down to the scheme/network if provided\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\n    // If the scheme is not provided, we accept any scheme.\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    // If the chain is not provided, we accept any chain.\n    const isExpectedChain = !network || (Array.isArray(network) ? network.includes(requirement.network) : network == requirement.network);\n\n    return isExpectedScheme && isExpectedChain;\n  });\n\n  // Filter down to USDC requirements\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\n    // If the address is a USDC address, we return it.\n    return requirement.asset === getUsdcChainConfigForChain(getNetworkId(requirement.network))?.usdcAddress;\n  });\n\n  // Prioritize USDC requirements if available\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  // If no USDC requirements are found, return the first broadly accepted requirement.\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  // If no matching requirements are found, return the first requirement.\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\") => PaymentRequirements;\n\n","import { signPaymentHeader as signPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { encodePayment } from \"../schemes/exact/evm/utils/paymentUtils\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, MultiNetworkSigner, Signer, SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the encoded signed payment header string\n */\nexport async function signPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n    if (!isEvmSignerWallet(evmClient)) {\n      throw new Error(\"Invalid evm wallet client provided\");\n    }\n    const signedPaymentHeader = await signPaymentHeaderExactEVM(evmClient, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAeA,eAAsBA,qBACpB,QACA,aACA,qBACA,QACiB;AAEjB,MAAI,oBAAoB,WAAW,SAAS;AAE1C,QAAI,qBAAqB,SAAS,oBAAoB,OAAO,GAAG;AAC9D,YAAM,YAAY,qBAAqB,MAAM,IAAI,OAAO,MAAM;AAE9D,UAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AAEA,aAAO,MAAM;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,qBAAqB,SAAS,oBAAoB,OAAO,GAAG;AAC9D,YAAM,YAAY,qBAAqB,MAAM,IAAI,OAAO,MAAM;AAC9D,UAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AAEA,aAAO,MAAMA;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AACA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;ACzCO,SAASC,sBACd,MACA,aACA,qBACwB;AACxB,MACE,oBAAoB,WAAW,WAC/B,qBAAqB,SAAS,oBAAoB,OAAO,GACzD;AACA,WAAO,qBAA6B,MAAM,aAAa,mBAAmB;AAAA,EAC5E;AAEA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;ACZO,SAAS,0BAA0B,qBAA4C,SAA+B,QAAuC;AAE1J,sBAAoB,KAAK,CAAC,GAAG,MAAM;AACjC,QAAI,EAAE,YAAY,UAAU,EAAE,YAAY,QAAQ;AAChD,aAAO;AAAA,IACT;AACA,QAAI,EAAE,YAAY,UAAU,EAAE,YAAY,QAAQ;AAChD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AAGD,QAAM,qCAAqC,oBAAoB,OAAO,iBAAe;AAEnF,UAAM,mBAAmB,CAAC,UAAU,YAAY,WAAW;AAE3D,UAAM,kBAAkB,CAAC,YAAY,MAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,YAAY,OAAO,IAAI,WAAW,YAAY;AAE7H,WAAO,oBAAoB;AAAA,EAC7B,CAAC;AAGD,QAAM,mBAAmB,mCAAmC,OAAO,iBAAe;AAEhF,WAAO,YAAY,UAAU,2BAA2B,aAAa,YAAY,OAAO,CAAC,GAAG;AAAA,EAC9F,CAAC;AAGD,MAAI,iBAAiB,SAAS,GAAG;AAC/B,WAAO,iBAAiB,CAAC;AAAA,EAC3B;AAEA,MAAI,mCAAmC,SAAS,GAAG;AACjD,WAAO,mCAAmC,CAAC;AAAA,EAC7C;AAEA,SAAO,oBAAoB,CAAC;AAC9B;;;ACvCA,eAAsBC,mBACpB,QACA,qBACA,uBACiB;AACjB,MACE,oBAAoB,WAAW,WAC/B,qBAAqB,SAAS,oBAAoB,OAAO,GACzD;AACA,UAAM,YAAY,qBAAqB,MAAM,IAAI,OAAO,MAAM;AAE9D,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AACA,UAAM,sBAAsB,MAAM,kBAA0B,WAAW,qBAAqB,qBAAqB;AACjH,WAAO,cAAc,mBAAmB;AAAA,EAC1C;AAEA,QAAM,IAAI,MAAM,oBAAoB;AACtC;","names":["createPaymentHeader","preparePaymentHeader","signPaymentHeader"]}