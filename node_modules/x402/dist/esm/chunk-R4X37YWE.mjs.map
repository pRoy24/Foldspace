{"version":3,"sources":["../../src/schemes/exact/index.ts","../../src/schemes/exact/evm/index.ts","../../src/schemes/exact/evm/facilitator.ts","../../src/schemes/exact/svm/index.ts","../../src/schemes/exact/svm/facilitator/settle.ts","../../src/schemes/exact/svm/facilitator/verify.ts"],"sourcesContent":["export * as evm from \"./evm\";\nexport * as svm from \"./svm\";\n\nexport const SCHEME = \"exact\";\n","export * from \"./client\";\nexport * from \"./facilitator\";\nexport * from \"./utils/paymentUtils\";\n","import { Account, Address, Chain, getAddress, Hex, parseErc6492Signature, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport { getVersion, getERC20Balance } from \"../../../shared/evm\";\nimport {\n  usdcABI as abi,\n  authorizationTypes,\n  config,\n  ConnectedClient,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n  ExactEvmPayload,\n} from \"../../../types/verify\";\nimport { SCHEME } from \"../../exact\";\n\n/**\n * Verifies a payment payload against the required payment details\n *\n * This function performs several verification steps:\n * - Verifies protocol version compatibility\n * - Validates the permit signature\n * - Confirms USDC contract address is correct for the chain\n * - Checks permit deadline is sufficiently in the future\n * - Verifies client has sufficient USDC balance\n * - Ensures payment amount meets required minimum\n *\n * @param client - The public client used for blockchain interactions\n * @param payload - The signed payment payload containing transfer parameters and signature\n * @param paymentRequirements - The payment requirements that the payload must satisfy\n * @returns A ValidPaymentRequest indicating if the payment is valid and any invalidation reason\n */\nexport async function verify<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined,\n>(\n  client: ConnectedClient<transport, chain, account>,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<VerifyResponse> {\n  /* TODO: work with security team on brainstorming more verification steps\n  verification steps:\n    - ✅ verify payload version\n    - ✅ verify usdc address is correct for the chain\n    - ✅ verify permit signature\n    - ✅ verify deadline\n    - verify nonce is current\n    - ✅ verify client has enough funds to cover paymentRequirements.maxAmountRequired\n    - ✅ verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n    - check min amount is above some threshold we think is reasonable for covering gas\n    - verify resource is not already paid for (next version)\n    */\n\n  const exactEvmPayload = payload.payload as ExactEvmPayload;\n\n  // Verify payload version\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\n    return {\n      isValid: false,\n      invalidReason: `unsupported_scheme`,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  let name: string;\n  let chainId: number;\n  let erc20Address: Address;\n  let version: string;\n  try {\n    chainId = getNetworkId(payload.network);\n    name = paymentRequirements.extra?.name ?? config[chainId.toString()].usdcName;\n    erc20Address = paymentRequirements.asset as Address;\n    version = paymentRequirements.extra?.version ?? (await getVersion(client));\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: `invalid_network`,\n      payer: (payload.payload as ExactEvmPayload).authorization.from,\n    };\n  }\n  // Verify permit signature is recoverable for the owner address\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: exactEvmPayload.authorization.from,\n      to: exactEvmPayload.authorization.to,\n      value: exactEvmPayload.authorization.value,\n      validAfter: exactEvmPayload.authorization.validAfter,\n      validBefore: exactEvmPayload.authorization.validBefore,\n      nonce: exactEvmPayload.authorization.nonce,\n    },\n  };\n  const recoveredAddress = await client.verifyTypedData({\n    address: exactEvmPayload.authorization.from as Address,\n    ...permitTypedData,\n    signature: exactEvmPayload.signature as Hex,\n  });\n  if (!recoveredAddress) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_signature\", //\"Invalid permit signature\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  // Verify that payment was made to the correct address\n  if (getAddress(exactEvmPayload.authorization.to) !== getAddress(paymentRequirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  // Verify deadline is not yet expired\n  // Pad 3 block to account for round tripping\n  if (\n    BigInt(exactEvmPayload.authorization.validBefore) < BigInt(Math.floor(Date.now() / 1000) + 6)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\", //\"Deadline on permit isn't far enough in the future\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  // Verify deadline is not yet valid\n  if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(Math.floor(Date.now() / 1000))) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\", //\"Deadline on permit is in the future\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  // Verify client has enough funds to cover paymentRequirements.maxAmountRequired\n  const balance = await getERC20Balance(\n    client,\n    erc20Address,\n    exactEvmPayload.authorization.from as Address,\n  );\n  if (balance < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"insufficient_funds\", //\"Client does not have enough funds\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  // Verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n  if (BigInt(exactEvmPayload.authorization.value) < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\", //\"Value in payload is not enough to cover paymentRequirements.maxAmountRequired\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer: exactEvmPayload.authorization.from,\n  };\n}\n\n/**\n * Settles a payment by executing a USDC transferWithAuthorization transaction\n *\n * This function executes the actual USDC transfer using the signed authorization from the user.\n * The facilitator wallet submits the transaction but does not need to hold or transfer any tokens itself.\n *\n * @param wallet - The facilitator wallet that will submit the transaction\n * @param paymentPayload - The signed payment payload containing the transfer parameters and signature\n * @param paymentRequirements - The original payment details that were used to create the payload\n * @returns A PaymentExecutionResponse containing the transaction status and hash\n */\nexport async function settle<transport extends Transport, chain extends Chain>(\n  wallet: SignerWallet<chain, transport>,\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<SettleResponse> {\n  const payload = paymentPayload.payload as ExactEvmPayload;\n\n  // re-verify to ensure the payment is still valid\n  const valid = await verify(wallet, paymentPayload, paymentRequirements);\n\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: paymentPayload.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\", //`Payment is no longer valid: ${valid.invalidReason}`,\n      payer: payload.authorization.from,\n    };\n  }\n\n  // Returns the original signature (no-op) if the signature is not a 6492 signature\n  const { signature } = parseErc6492Signature(payload.signature as Hex);\n\n  const tx = await wallet.writeContract({\n    address: paymentRequirements.asset as Address,\n    abi,\n    functionName: \"transferWithAuthorization\" as const,\n    args: [\n      payload.authorization.from as Address,\n      payload.authorization.to as Address,\n      BigInt(payload.authorization.value),\n      BigInt(payload.authorization.validAfter),\n      BigInt(payload.authorization.validBefore),\n      payload.authorization.nonce as Hex,\n      signature,\n    ],\n    chain: wallet.chain as Chain,\n  });\n\n  const receipt = await wallet.waitForTransactionReceipt({ hash: tx });\n\n  if (receipt.status !== \"success\") {\n    return {\n      success: false,\n      errorReason: \"invalid_transaction_state\", //`Transaction failed`,\n      transaction: tx,\n      network: paymentPayload.network,\n      payer: payload.authorization.from,\n    };\n  }\n\n  return {\n    success: true,\n    transaction: tx,\n    network: paymentPayload.network,\n    payer: payload.authorization.from,\n  };\n}\n","export * from \"./facilitator/index\";\nexport * from \"./client\";\n","import {\n  SettleResponse,\n  PaymentPayload,\n  PaymentRequirements,\n  ExactSvmPayload,\n  ErrorReasons,\n} from \"../../../../types/verify\";\nimport { X402Config } from \"../../../../types/config\";\nimport {\n  assertIsTransactionMessageWithBlockhashLifetime,\n  Commitment,\n  decompileTransactionMessageFetchingLookupTables,\n  getBase64EncodedWireTransaction,\n  getCompiledTransactionMessageDecoder,\n  getSignatureFromTransaction,\n  isSolanaError,\n  KeyPairSigner,\n  SendTransactionApi,\n  signTransaction,\n  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcDevnet,\n  RpcMainnet,\n} from \"@solana/kit\";\nimport { decodeTransactionFromPayload } from \"../../../../shared/svm\";\nimport { getRpcClient, getRpcSubscriptions } from \"../../../../shared/svm/rpc\";\nimport {\n  createBlockHeightExceedencePromiseFactory,\n  waitForRecentTransactionConfirmation,\n  createRecentSignatureConfirmationPromiseFactory,\n} from \"@solana/transaction-confirmation\";\nimport { verify } from \"./verify\";\n\n/**\n * Settle the payment payload against the payment requirements.\n * TODO: handle durable nonce lifetime transactions\n *\n * @param signer - The signer that will sign the transaction\n * @param payload - The payment payload to settle\n * @param paymentRequirements - The payment requirements to settle against\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A SettleResponse indicating if the payment is settled and any error reason\n */\nexport async function settle(\n  signer: KeyPairSigner,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<SettleResponse> {\n  const verifyResponse = await verify(signer, payload, paymentRequirements, config);\n  if (!verifyResponse.isValid) {\n    return {\n      success: false,\n      errorReason: verifyResponse.invalidReason,\n      network: payload.network,\n      transaction: \"\",\n    };\n  }\n\n  const svmPayload = payload.payload as ExactSvmPayload;\n  const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n  const signedTransaction = await signTransaction([signer.keyPair], decodedTransaction);\n  const payer = signer.address.toString();\n\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const rpcSubscriptions = getRpcSubscriptions(\n    paymentRequirements.network,\n    config?.svmConfig?.rpcUrl,\n  );\n\n  try {\n    const { success, errorReason, signature } = await sendAndConfirmSignedTransaction(\n      signedTransaction,\n      rpc,\n      rpcSubscriptions,\n    );\n\n    return {\n      success,\n      errorReason,\n      payer,\n      transaction: signature,\n      network: payload.network,\n    };\n  } catch (error) {\n    console.error(\"Unexpected error during transaction settlement:\", error);\n    return {\n      success: false,\n      errorReason: \"unexpected_settle_error\",\n      network: payload.network,\n      transaction: getSignatureFromTransaction(signedTransaction),\n    };\n  }\n}\n\n/**\n * Send a signed transaction to the RPC.\n * TODO: should this be moved to the shared/svm/rpc.ts file?\n *\n * @param signedTransaction - The signed transaction to send\n * @param rpc - The RPC client to use to send the transaction\n * @param sendTxConfig - The configuration for the transaction send\n * @returns The signature of the sent transaction\n */\nexport async function sendSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  sendTxConfig: Parameters<SendTransactionApi[\"sendTransaction\"]>[1] = {\n    skipPreflight: true,\n    encoding: \"base64\",\n  },\n): Promise<string> {\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n  return await rpc.sendTransaction(base64EncodedTransaction, sendTxConfig).send();\n}\n\n/**\n * Confirm a signed transaction.\n * TODO: can some of this be refactored to be moved to the shared/svm/rpc.ts file?\n * TODO: should the commitment and the timeout be passed in as parameters?\n *\n * @param signedTransaction - The signed transaction to confirm\n * @param rpc - The RPC client to use to confirm the transaction\n * @param rpcSubscriptions - The RPC subscriptions to use to confirm the transaction\n * @returns The success and signature of the confirmed transaction\n */\nexport async function confirmSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  rpcSubscriptions: ReturnType<typeof getRpcSubscriptions>,\n): Promise<{ success: boolean; errorReason?: (typeof ErrorReasons)[number]; signature: string }> {\n  // get the signature from the signed transaction\n  const signature = getSignatureFromTransaction(signedTransaction);\n\n  // set a timeout for the transaction confirmation\n  const abortController = new AbortController();\n  const timeout = setTimeout(() => {\n    abortController.abort(\"Transaction confirmation timed out after 60 seconds\");\n  }, 60000);\n\n  try {\n    // decompile the transaction message to get the blockhash lifetime\n    const compiledTransactionMessage = getCompiledTransactionMessageDecoder().decode(\n      signedTransaction.messageBytes,\n    );\n    const decompiledTransactionMessage = await decompileTransactionMessageFetchingLookupTables(\n      compiledTransactionMessage,\n      rpc,\n    );\n    assertIsTransactionMessageWithBlockhashLifetime(decompiledTransactionMessage);\n\n    // add the blockhash lifetime to the signed transaction\n    const signedTransactionWithBlockhashLifetime = {\n      ...signedTransaction,\n      lifetimeConstraint: decompiledTransactionMessage.lifetimeConstraint,\n    };\n\n    // create the config for the transaction confirmation\n    const commitment: Commitment = \"confirmed\";\n\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n      rpc,\n      rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n      rpc,\n      rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n\n    const config = {\n      abortSignal: abortController.signal,\n      commitment,\n      getBlockHeightExceedencePromise,\n      getRecentSignatureConfirmationPromise,\n    };\n\n    // wait for the transaction to be confirmed\n    await waitForRecentTransactionConfirmation({\n      ...config,\n      transaction: signedTransactionWithBlockhashLifetime,\n    });\n\n    // return the success and signature\n    return {\n      success: true,\n      signature,\n    };\n  } catch (error) {\n    console.error(error);\n\n    // block height exceeded error\n    if (isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n      return {\n        success: false,\n        errorReason: \"settle_exact_svm_block_height_exceeded\",\n        signature,\n      };\n    }\n    // transaction confirmation timed out error\n    else if (error instanceof DOMException && error.name === \"AbortError\") {\n      return {\n        success: false,\n        errorReason: \"settle_exact_svm_transaction_confirmation_timed_out\",\n        signature,\n      };\n    }\n    // unexpected error\n    else {\n      throw error;\n    }\n  } finally {\n    // clear the timeout\n    clearTimeout(timeout);\n  }\n}\n\n/**\n * Send and confirm a signed transaction.\n *\n * @param signedTransaction - The signed transaction to send and confirm\n * @param rpc - The RPC client to use to send and confirm the transaction\n * @param rpcSubscriptions - The RPC subscriptions to use to send and confirm the transaction\n * @returns The success and signature of the confirmed transaction\n */\nexport async function sendAndConfirmSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  rpcSubscriptions: ReturnType<typeof getRpcSubscriptions>,\n): Promise<{ success: boolean; errorReason?: (typeof ErrorReasons)[number]; signature: string }> {\n  await sendSignedTransaction(signedTransaction, rpc);\n  return await confirmSignedTransaction(signedTransaction, rpc, rpcSubscriptions);\n}\n","import {\n  VerifyResponse,\n  PaymentPayload,\n  PaymentRequirements,\n  ExactSvmPayload,\n  ErrorReasons,\n} from \"../../../../types/verify\";\nimport { SupportedSVMNetworks } from \"../../../../types/shared\";\nimport { X402Config } from \"../../../../types/config\";\nimport {\n  Address,\n  assertIsInstructionWithAccounts,\n  assertIsInstructionWithData,\n  CompilableTransactionMessage,\n  decompileTransactionMessageFetchingLookupTables,\n  fetchEncodedAccounts,\n  getCompiledTransactionMessageDecoder,\n  KeyPairSigner,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcDevnet,\n  RpcMainnet,\n  Instruction,\n  AccountLookupMeta,\n  AccountMeta,\n  InstructionWithData,\n} from \"@solana/kit\";\nimport {\n  parseSetComputeUnitLimitInstruction,\n  parseSetComputeUnitPriceInstruction,\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n} from \"@solana-program/compute-budget\";\nimport {\n  findAssociatedTokenPda,\n  identifyToken2022Instruction,\n  parseCreateAssociatedTokenInstruction,\n  parseTransferCheckedInstruction as parseTransferCheckedInstruction2022,\n  Token2022Instruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport {\n  identifyTokenInstruction,\n  parseTransferCheckedInstruction as parseTransferCheckedInstructionToken,\n  TOKEN_PROGRAM_ADDRESS,\n  TokenInstruction,\n} from \"@solana-program/token\";\nimport { decodeTransactionFromPayload, signAndSimulateTransaction } from \"../../../../shared/svm\";\nimport { getRpcClient } from \"../../../../shared/svm/rpc\";\nimport { SCHEME } from \"../../\";\n\n/**\n * Verify the payment payload against the payment requirements.\n *\n * @param signer - The signer that will sign and simulate the transaction\n * @param payload - The payment payload to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A VerifyResponse indicating if the payment is valid and any invalidation reason\n */\nexport async function verify(\n  signer: KeyPairSigner,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<VerifyResponse> {\n  try {\n    // verify that the scheme and network are supported\n    verifySchemesAndNetworks(payload, paymentRequirements);\n\n    // decode the base64 encoded transaction\n    const svmPayload = payload.payload as ExactSvmPayload;\n    const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n    const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n\n    // perform transaction introspection to validate the transaction structure and details\n    await transactionIntrospection(svmPayload, paymentRequirements, config);\n\n    // simulate the transaction to ensure it will execute successfully\n    const simulateResult = await signAndSimulateTransaction(signer, decodedTransaction, rpc);\n    if (simulateResult.value?.err) {\n      throw new Error(`invalid_exact_svm_payload_transaction_simulation_failed`);\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n    };\n  } catch (error) {\n    // if the error is one of the known error reasons, return the error reason\n    if (error instanceof Error) {\n      if (ErrorReasons.includes(error.message as (typeof ErrorReasons)[number])) {\n        return {\n          isValid: false,\n          invalidReason: error.message as (typeof ErrorReasons)[number],\n        };\n      }\n    }\n\n    // if the error is not one of the known error reasons, return an unexpected error reason\n    console.error(error);\n    return {\n      isValid: false,\n      invalidReason: \"unexpected_verify_error\",\n    };\n  }\n}\n\n/**\n * Verify that the scheme and network are supported.\n *\n * @param payload - The payment payload to verify\n * @param paymentRequirements - The payment requirements to verify against\n */\nexport function verifySchemesAndNetworks(\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): void {\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\n    throw new Error(\"unsupported_scheme\");\n  }\n\n  if (\n    payload.network !== paymentRequirements.network ||\n    !SupportedSVMNetworks.includes(paymentRequirements.network)\n  ) {\n    throw new Error(\"invalid_network\");\n  }\n}\n\n/**\n * Perform transaction introspection to validate the transaction structure and transfer details.\n * This function handles decoding the transaction, validating the transfer instruction,\n * and verifying all transfer details against the payment requirements.\n *\n * @param svmPayload - The SVM payload containing the transaction\n * @param paymentRequirements - The payment requirements to verify against\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n */\nexport async function transactionIntrospection(\n  svmPayload: ExactSvmPayload,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<void> {\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n  const compiledTransactionMessage = getCompiledTransactionMessageDecoder().decode(\n    decodedTransaction.messageBytes,\n  );\n  const transactionMessage = await decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage,\n    rpc,\n  );\n\n  // verify that the transaction contains the expected instructions\n  await verifyTransactionInstructions(transactionMessage, paymentRequirements, rpc);\n}\n\n/**\n * Verify that the transaction contains the expected instructions.\n *\n * @param transactionMessage - The transaction message to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param rpc - The RPC client to use for verifying account existence\n * @throws Error if the transaction does not contain the expected instructions\n */\nexport async function verifyTransactionInstructions(\n  transactionMessage: CompilableTransactionMessage,\n  paymentRequirements: PaymentRequirements,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  // validate the number of expected instructions\n  if (\n    transactionMessage.instructions.length !== 3 &&\n    transactionMessage.instructions.length !== 4\n  ) {\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_length`);\n  }\n\n  // verify that the compute limit and price instructions are valid\n  verifyComputeLimitInstruction(transactionMessage.instructions[0]);\n  verifyComputePriceInstruction(transactionMessage.instructions[1]);\n\n  // verify that the transfer instruction is valid\n  // this expects the destination ATA to already exist\n  if (transactionMessage.instructions.length === 3) {\n    await verifyTransferInstruction(\n      transactionMessage.instructions[2],\n      paymentRequirements,\n      {\n        txHasCreateDestATAInstruction: false,\n      },\n      rpc,\n    );\n  }\n\n  // verify that the transfer instruction is valid\n  // this expects the destination ATA to be created in the same transaction\n  else {\n    verifyCreateATAInstruction(transactionMessage.instructions[2], paymentRequirements);\n    await verifyTransferInstruction(\n      transactionMessage.instructions[3],\n      paymentRequirements,\n      {\n        txHasCreateDestATAInstruction: true,\n      },\n      rpc,\n    );\n  }\n}\n\n/**\n * Verify that the compute limit instruction is valid.\n *\n * @param instruction - The compute limit instruction to verify\n * @throws Error if the compute limit instruction is invalid\n */\nexport function verifyComputeLimitInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  try {\n    if (\n      instruction.programAddress.toString() !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n      instruction.data?.[0] !== 2 // discriminator of set compute unit limit instruction\n    ) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction`,\n      );\n    }\n    parseSetComputeUnitLimitInstruction(\n      instruction as InstructionWithData<Uint8Array<ArrayBufferLike>>,\n    );\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction`);\n  }\n}\n\n/**\n * Verify that the compute price instruction is valid.\n * This function throws an error if the compute unit price is greater than 5 lamports,\n * to protect the facilitator against gas fee abuse from the client.\n *\n * @param instruction - The compute price instruction to verify\n * @throws Error if the compute price instruction is invalid\n */\nexport function verifyComputePriceInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  if (\n    instruction.programAddress.toString() !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n    instruction.data?.[0] !== 3 // discriminator of set compute unit price instruction\n  ) {\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_compute_price_instruction`);\n  }\n  const parsedInstruction = parseSetComputeUnitPriceInstruction(\n    instruction as InstructionWithData<Uint8Array<ArrayBufferLike>>,\n  );\n\n  // TODO: allow the facilitator to pass in an optional max compute unit price\n  if (parsedInstruction.data.microLamports > 5 * 1_000_000) {\n    throw new Error(\n      `invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high`,\n    );\n  }\n}\n\n/**\n * Verify that the create ATA instruction is valid.\n *\n * @param instruction - The create ATA instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @throws Error if the create ATA instruction is invalid\n */\nexport function verifyCreateATAInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n  paymentRequirements: PaymentRequirements,\n) {\n  let createATAInstruction: ReturnType<typeof parseCreateAssociatedTokenInstruction>;\n\n  // validate and refine the type of the create ATA instruction\n  try {\n    assertIsInstructionWithAccounts(instruction);\n    assertIsInstructionWithData(instruction);\n\n    // parse the create ATA instruction\n    createATAInstruction = parseCreateAssociatedTokenInstruction({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction`);\n  }\n\n  // verify that the ATA is created for the expected payee\n  if (createATAInstruction.accounts.owner.address !== paymentRequirements.payTo) {\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee`);\n  }\n\n  // verify that the ATA is created for the expected asset\n  if (createATAInstruction.accounts.mint.address !== paymentRequirements.asset) {\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset`);\n  }\n}\n\n/**\n * Verify that the transfer instruction is valid.\n *\n * @param instruction - The transfer instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param {object} options - The options for the verification of the transfer instruction\n * @param {boolean} options.txHasCreateDestATAInstruction - Whether the transaction has a create destination ATA instruction\n * @param rpc - The RPC client to use for verifying account existence\n * @throws Error if the transfer instruction is invalid\n */\nexport async function verifyTransferInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n  paymentRequirements: PaymentRequirements,\n  { txHasCreateDestATAInstruction }: { txHasCreateDestATAInstruction: boolean },\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  // get a validated and parsed transferChecked instruction\n  const tokenInstruction = getValidatedTransferCheckedInstruction(instruction);\n  await verifyTransferCheckedInstruction(\n    tokenInstruction,\n    paymentRequirements,\n    {\n      txHasCreateDestATAInstruction,\n    },\n    rpc,\n  );\n}\n\n/**\n * Verify that the transfer checked instruction is valid.\n *\n * @param parsedInstruction - The parsed transfer checked instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param {object} options - The options for the verification of the transfer checked instruction\n * @param {boolean} options.txHasCreateDestATAInstruction - Whether the transaction has a create destination ATA instruction\n * @param rpc - The RPC client to use for verifying account existence\n * @throws Error if the transfer checked instruction is invalid\n */\nexport async function verifyTransferCheckedInstruction(\n  parsedInstruction: ReturnType<typeof parseTransferCheckedInstruction2022>,\n  paymentRequirements: PaymentRequirements,\n  { txHasCreateDestATAInstruction }: { txHasCreateDestATAInstruction: boolean },\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  // get the token program address\n  const tokenProgramAddress =\n    parsedInstruction.programAddress.toString() === TOKEN_PROGRAM_ADDRESS.toString()\n      ? TOKEN_PROGRAM_ADDRESS\n      : TOKEN_2022_PROGRAM_ADDRESS;\n\n  // get the expected receiver's ATA\n  const payToATA = await findAssociatedTokenPda({\n    mint: paymentRequirements.asset as Address,\n    owner: paymentRequirements.payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  // verify that the transfer is to the expected ATA\n  if (parsedInstruction.accounts.destination.address !== payToATA[0]) {\n    throw new Error(`invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata`);\n  }\n\n  // verify that the source and destination ATAs exist\n  const addresses = [parsedInstruction.accounts.source.address, payToATA[0]];\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses);\n  const missingAccounts = maybeAccounts.filter(a => !a.exists);\n  for (const missingAccount of missingAccounts) {\n    if (missingAccount.address === parsedInstruction.accounts.source.address) {\n      throw new Error(`invalid_exact_svm_payload_transaction_sender_ata_not_found`);\n    }\n    if (missingAccount.address === payToATA[0] && !txHasCreateDestATAInstruction) {\n      throw new Error(`invalid_exact_svm_payload_transaction_receiver_ata_not_found`);\n    }\n  }\n\n  // verify that the amount is correct\n  const instructionAmount = parsedInstruction.data.amount;\n  const paymentRequirementsAmount = BigInt(paymentRequirements.maxAmountRequired);\n  if (instructionAmount !== paymentRequirementsAmount) {\n    throw new Error(`invalid_exact_svm_payload_transaction_amount_mismatch`);\n  }\n}\n\n/**\n * Inspect the decompiled transaction message to make sure that it is a valid\n * transfer instruction.\n *\n * @param instruction - The instruction to get the transfer instruction from\n * @returns The validated transfer instruction\n * @throws Error if the instruction is not a valid transfer checked instruction\n */\nexport function getValidatedTransferCheckedInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  try {\n    assertIsInstructionWithData(instruction);\n    assertIsInstructionWithAccounts(instruction);\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions`);\n  }\n\n  let tokenInstruction;\n\n  // spl-token program\n  if (instruction.programAddress.toString() === TOKEN_PROGRAM_ADDRESS.toString()) {\n    const identifiedInstruction = identifyTokenInstruction(instruction);\n    if (identifiedInstruction !== TokenInstruction.TransferChecked) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked`,\n      );\n    }\n    tokenInstruction = parseTransferCheckedInstructionToken({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  }\n  // token-2022 program\n  else if (instruction.programAddress.toString() === TOKEN_2022_PROGRAM_ADDRESS.toString()) {\n    const identifiedInstruction = identifyToken2022Instruction(instruction);\n    if (identifiedInstruction !== Token2022Instruction.TransferChecked) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked`,\n      );\n    }\n    tokenInstruction = parseTransferCheckedInstruction2022({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  }\n  // invalid instruction\n  else {\n    throw new Error(`invalid_exact_svm_payload_transaction_not_a_transfer_instruction`);\n  }\n\n  return tokenInstruction;\n}\n"],"mappings":"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","names":["createPaymentHeader","settle","verify","decompileTransactionMessageFetchingLookupTables","getCompiledTransactionMessageDecoder","verify","config","settle","config","verify","getCompiledTransactionMessageDecoder","decompileTransactionMessageFetchingLookupTables"]}