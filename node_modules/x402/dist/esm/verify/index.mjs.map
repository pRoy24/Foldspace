{"version":3,"sources":["../../../src/verify/useFacilitator.ts"],"sourcesContent":["import { toJsonSafe } from \"../shared\";\nimport {\n  ListDiscoveryResourcesRequest,\n  ListDiscoveryResourcesResponse,\n  FacilitatorConfig,\n  SupportedPaymentKindsResponse,\n} from \"../types\";\nimport {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"../types/verify\";\n\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\n\nexport type CreateHeaders = () => Promise<{\n  verify: Record<string, string>;\n  settle: Record<string, string>;\n  supported: Record<string, string>;\n  list?: Record<string, string>;\n}>;\n\n/**\n * Creates a facilitator client for interacting with the X402 payment facilitator service\n *\n * @param facilitator - The facilitator config to use. If not provided, the default facilitator will be used.\n * @returns An object containing verify and settle functions for interacting with the facilitator\n */\nexport function useFacilitator(facilitator?: FacilitatorConfig) {\n  /**\n   * Verifies a payment payload with the facilitator service\n   *\n   * @param payload - The payment payload to verify\n   * @param paymentRequirements - The payment requirements to verify against\n   * @returns A promise that resolves to the verification response\n   */\n  async function verify(\n    payload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\n\n    let headers = { \"Content-Type\": \"application/json\" };\n    if (facilitator?.createAuthHeaders) {\n      const authHeaders = await facilitator.createAuthHeaders();\n      headers = { ...headers, ...authHeaders.verify };\n    }\n\n    const res = await fetch(`${url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: payload.x402Version,\n        paymentPayload: toJsonSafe(payload),\n        paymentRequirements: toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    if (res.status !== 200) {\n      throw new Error(`Failed to verify payment: ${res.statusText}`);\n    }\n\n    const data = await res.json();\n    return data as VerifyResponse;\n  }\n\n  /**\n   * Settles a payment with the facilitator service\n   *\n   * @param payload - The payment payload to settle\n   * @param paymentRequirements - The payment requirements for the settlement\n   * @returns A promise that resolves to the settlement response\n   */\n  async function settle(\n    payload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\n\n    let headers = { \"Content-Type\": \"application/json\" };\n    if (facilitator?.createAuthHeaders) {\n      const authHeaders = await facilitator.createAuthHeaders();\n      headers = { ...headers, ...authHeaders.settle };\n    }\n\n    const res = await fetch(`${url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: payload.x402Version,\n        paymentPayload: toJsonSafe(payload),\n        paymentRequirements: toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    if (res.status !== 200) {\n      const text = res.statusText;\n      throw new Error(`Failed to settle payment: ${res.status} ${text}`);\n    }\n\n    const data = await res.json();\n    return data as SettleResponse;\n  }\n\n  /**\n   * Gets the supported payment kinds from the facilitator service.\n   *\n   * @returns A promise that resolves to the supported payment kinds\n   */\n  async function supported(): Promise<SupportedPaymentKindsResponse> {\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\n\n    let headers = { \"Content-Type\": \"application/json\" };\n    if (facilitator?.createAuthHeaders) {\n      const authHeaders = await facilitator.createAuthHeaders();\n      headers = { ...headers, ...authHeaders.supported };\n    }\n\n    const res = await fetch(`${url}/supported`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (res.status !== 200) {\n      throw new Error(`Failed to get supported payment kinds: ${res.statusText}`);\n    }\n\n    const data = await res.json();\n    return data as SupportedPaymentKindsResponse;\n  }\n\n  /**\n   * Lists the discovery items with the facilitator service\n   *\n   * @param config - The configuration for the discovery list request\n   * @returns A promise that resolves to the discovery list response\n   */\n  async function list(\n    config: ListDiscoveryResourcesRequest = {},\n  ): Promise<ListDiscoveryResourcesResponse> {\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\n\n    let headers = { \"Content-Type\": \"application/json\" };\n    if (facilitator?.createAuthHeaders) {\n      const authHeaders = await facilitator.createAuthHeaders();\n      if (authHeaders.list) {\n        headers = { ...headers, ...authHeaders.list };\n      }\n    }\n\n    const urlParams = new URLSearchParams(\n      Object.entries(config)\n        .filter(([_, value]) => value !== undefined)\n        .map(([key, value]) => [key, value.toString()]),\n    );\n\n    const res = await fetch(`${url}/discovery/resources?${urlParams.toString()}`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (res.status !== 200) {\n      const text = res.statusText;\n      throw new Error(`Failed to list discovery: ${res.status} ${text}`);\n    }\n\n    const data = await res.json();\n    return data as ListDiscoveryResourcesResponse;\n  }\n\n  return { verify, settle, supported, list };\n}\n\nexport const { verify, settle, supported, list } = useFacilitator();\n"],"mappings":";;;;;;AAcA,IAAM,0BAA0B;AAezB,SAAS,eAAe,aAAiC;AAQ9D,iBAAeA,QACb,SACA,qBACyB;AACzB,UAAM,MAAM,aAAa,OAAO;AAEhC,QAAI,UAAU,EAAE,gBAAgB,mBAAmB;AACnD,QAAI,aAAa,mBAAmB;AAClC,YAAM,cAAc,MAAM,YAAY,kBAAkB;AACxD,gBAAU,EAAE,GAAG,SAAS,GAAG,YAAY,OAAO;AAAA,IAChD;AAEA,UAAM,MAAM,MAAM,MAAM,GAAG,GAAG,WAAW;AAAA,MACvC,QAAQ;AAAA,MACR;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACnB,aAAa,QAAQ;AAAA,QACrB,gBAAgB,WAAW,OAAO;AAAA,QAClC,qBAAqB,WAAW,mBAAmB;AAAA,MACrD,CAAC;AAAA,IACH,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,IAAI,MAAM,6BAA6B,IAAI,UAAU,EAAE;AAAA,IAC/D;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,WAAO;AAAA,EACT;AASA,iBAAeC,QACb,SACA,qBACyB;AACzB,UAAM,MAAM,aAAa,OAAO;AAEhC,QAAI,UAAU,EAAE,gBAAgB,mBAAmB;AACnD,QAAI,aAAa,mBAAmB;AAClC,YAAM,cAAc,MAAM,YAAY,kBAAkB;AACxD,gBAAU,EAAE,GAAG,SAAS,GAAG,YAAY,OAAO;AAAA,IAChD;AAEA,UAAM,MAAM,MAAM,MAAM,GAAG,GAAG,WAAW;AAAA,MACvC,QAAQ;AAAA,MACR;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACnB,aAAa,QAAQ;AAAA,QACrB,gBAAgB,WAAW,OAAO;AAAA,QAClC,qBAAqB,WAAW,mBAAmB;AAAA,MACrD,CAAC;AAAA,IACH,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,OAAO,IAAI;AACjB,YAAM,IAAI,MAAM,6BAA6B,IAAI,MAAM,IAAI,IAAI,EAAE;AAAA,IACnE;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,WAAO;AAAA,EACT;AAOA,iBAAeC,aAAoD;AACjE,UAAM,MAAM,aAAa,OAAO;AAEhC,QAAI,UAAU,EAAE,gBAAgB,mBAAmB;AACnD,QAAI,aAAa,mBAAmB;AAClC,YAAM,cAAc,MAAM,YAAY,kBAAkB;AACxD,gBAAU,EAAE,GAAG,SAAS,GAAG,YAAY,UAAU;AAAA,IACnD;AAEA,UAAM,MAAM,MAAM,MAAM,GAAG,GAAG,cAAc;AAAA,MAC1C,QAAQ;AAAA,MACR;AAAA,IACF,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,IAAI,MAAM,0CAA0C,IAAI,UAAU,EAAE;AAAA,IAC5E;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,WAAO;AAAA,EACT;AAQA,iBAAeC,MACb,SAAwC,CAAC,GACA;AACzC,UAAM,MAAM,aAAa,OAAO;AAEhC,QAAI,UAAU,EAAE,gBAAgB,mBAAmB;AACnD,QAAI,aAAa,mBAAmB;AAClC,YAAM,cAAc,MAAM,YAAY,kBAAkB;AACxD,UAAI,YAAY,MAAM;AACpB,kBAAU,EAAE,GAAG,SAAS,GAAG,YAAY,KAAK;AAAA,MAC9C;AAAA,IACF;AAEA,UAAM,YAAY,IAAI;AAAA,MACpB,OAAO,QAAQ,MAAM,EAClB,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,MAAS,EAC1C,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,MAAM,SAAS,CAAC,CAAC;AAAA,IAClD;AAEA,UAAM,MAAM,MAAM,MAAM,GAAG,GAAG,wBAAwB,UAAU,SAAS,CAAC,IAAI;AAAA,MAC5E,QAAQ;AAAA,MACR;AAAA,IACF,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,OAAO,IAAI;AACjB,YAAM,IAAI,MAAM,6BAA6B,IAAI,MAAM,IAAI,IAAI,EAAE;AAAA,IACnE;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,WAAO;AAAA,EACT;AAEA,SAAO,EAAE,QAAAH,SAAQ,QAAAC,SAAQ,WAAAC,YAAW,MAAAC,MAAK;AAC3C;AAEO,IAAM,EAAE,QAAQ,QAAQ,WAAW,KAAK,IAAI,eAAe;","names":["verify","settle","supported","list"]}